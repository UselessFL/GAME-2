import {
  DEG_TO_RAD,
  Filter,
  ObservablePoint,
  Point,
  lib_exports,
  settings
} from "./chunk-G2HX2YNS.js";
import "./chunk-ZS7NZCD4.js";

// node_modules/@pixi/filter-kawase-blur/dist/filter-kawase-blur.mjs
var c = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
var v = `
varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform vec2 uOffset;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample top right pixel
    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y));

    // Sample bottom right pixel
    color += texture2D(uSampler, vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y));

    // Sample bottom left pixel
    color += texture2D(uSampler, vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y));

    // Average
    color *= 0.25;

    gl_FragColor = color;
}`;
var y = `
varying vec2 vTextureCoord;
uniform sampler2D uSampler;

uniform vec2 uOffset;
uniform vec4 filterClamp;

void main(void)
{
    vec4 color = vec4(0.0);

    // Sample top left pixel
    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));

    // Sample top right pixel
    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y + uOffset.y), filterClamp.xy, filterClamp.zw));

    // Sample bottom right pixel
    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x + uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));

    // Sample bottom left pixel
    color += texture2D(uSampler, clamp(vec2(vTextureCoord.x - uOffset.x, vTextureCoord.y - uOffset.y), filterClamp.xy, filterClamp.zw));

    // Average
    color *= 0.25;

    gl_FragColor = color;
}
`;
var _ = class extends Filter {
  constructor(e = 4, t = 3, i = false) {
    super(c, i ? y : v), this._kernels = [], this._blur = 4, this._quality = 3, this.uniforms.uOffset = new Float32Array(2), this._pixelSize = new Point(), this.pixelSize = 1, this._clamp = i, Array.isArray(e) ? this.kernels = e : (this._blur = e, this.quality = t);
  }
  apply(e, t, i, o2) {
    const n = this._pixelSize.x / t._frame.width, l = this._pixelSize.y / t._frame.height;
    let r;
    if (this._quality === 1 || this._blur === 0)
      r = this._kernels[0] + 0.5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, t, i, o2);
    else {
      const x = e.getFilterTexture();
      let s = t, u = x, f;
      const p = this._quality - 1;
      for (let a = 0; a < p; a++)
        r = this._kernels[a] + 0.5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, s, u, 1), f = s, s = u, u = f;
      r = this._kernels[p] + 0.5, this.uniforms.uOffset[0] = r * n, this.uniforms.uOffset[1] = r * l, e.applyFilter(this, s, i, o2), e.returnFilterTexture(x);
    }
  }
  _updatePadding() {
    this.padding = Math.ceil(this._kernels.reduce((e, t) => e + t + 0.5, 0));
  }
  _generateKernels() {
    const e = this._blur, t = this._quality, i = [e];
    if (e > 0) {
      let o2 = e;
      const n = e / t;
      for (let l = 1; l < t; l++)
        o2 -= n, i.push(o2);
    }
    this._kernels = i, this._updatePadding();
  }
  get kernels() {
    return this._kernels;
  }
  set kernels(e) {
    Array.isArray(e) && e.length > 0 ? (this._kernels = e, this._quality = e.length, this._blur = Math.max(...e)) : (this._kernels = [0], this._quality = 1);
  }
  get clamp() {
    return this._clamp;
  }
  set pixelSize(e) {
    typeof e == "number" ? (this._pixelSize.x = e, this._pixelSize.y = e) : Array.isArray(e) ? (this._pixelSize.x = e[0], this._pixelSize.y = e[1]) : e instanceof Point ? (this._pixelSize.x = e.x, this._pixelSize.y = e.y) : (this._pixelSize.x = 1, this._pixelSize.y = 1);
  }
  get pixelSize() {
    return this._pixelSize;
  }
  get quality() {
    return this._quality;
  }
  set quality(e) {
    this._quality = Math.max(1, Math.round(e)), this._generateKernels();
  }
  get blur() {
    return this._blur;
  }
  set blur(e) {
    this._blur = e, this._generateKernels();
  }
};

// node_modules/@pixi/filter-drop-shadow/dist/filter-drop-shadow.mjs
var w = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`;
var O = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float alpha;
uniform vec3 color;

uniform vec2 shift;
uniform vec4 inputSize;

void main(void){
    vec4 sample = texture2D(uSampler, vTextureCoord - shift * inputSize.zw);

    // Premultiply alpha
    sample.rgb = color.rgb * sample.a;

    // alpha user alpha
    sample *= alpha;

    gl_FragColor = sample;
}`;
var P = Object.defineProperty;
var c2 = Object.getOwnPropertySymbols;
var T = Object.prototype.hasOwnProperty;
var z = Object.prototype.propertyIsEnumerable;
var _2 = (t, e, i) => e in t ? P(t, e, { enumerable: true, configurable: true, writable: true, value: i }) : t[e] = i;
var b = (t, e) => {
  for (var i in e || (e = {}))
    T.call(e, i) && _2(t, i, e[i]);
  if (c2)
    for (var i of c2(e))
      z.call(e, i) && _2(t, i, e[i]);
  return t;
};
var o = class extends Filter {
  constructor(t) {
    super(), this.angle = 45, this._distance = 5, this._resolution = settings.FILTER_RESOLUTION;
    const e = t ? b(b({}, o.defaults), t) : o.defaults, { kernels: i, blur: l, quality: r, pixelSize: g, resolution: n } = e;
    this._offset = new ObservablePoint(this._updatePadding, this), this._tintFilter = new Filter(w, O), this._tintFilter.uniforms.color = new Float32Array(4), this._tintFilter.uniforms.shift = this._offset, this._tintFilter.resolution = n, this._blurFilter = i ? new _(i) : new _(l, r), this.pixelSize = g, this.resolution = n;
    const { shadowOnly: m, rotation: a, distance: u, offset: v2, alpha: y2, color: x } = e;
    this.shadowOnly = m, a !== void 0 && u !== void 0 ? (this.rotation = a, this.distance = u) : this.offset = v2, this.alpha = y2, this.color = x;
  }
  apply(t, e, i, l) {
    const r = t.getFilterTexture();
    this._tintFilter.apply(t, e, r, 1), this._blurFilter.apply(t, r, i, l), this.shadowOnly !== true && t.applyFilter(this, e, i, 0), t.returnFilterTexture(r);
  }
  _updatePadding() {
    const t = Math.max(Math.abs(this._offset.x), Math.abs(this._offset.y));
    this.padding = t + this.blur * 2;
  }
  _updateShift() {
    this._tintFilter.uniforms.shift.set(this.distance * Math.cos(this.angle), this.distance * Math.sin(this.angle));
  }
  set offset(t) {
    this._offset.copyFrom(t), this._updatePadding();
  }
  get offset() {
    return this._offset;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(t) {
    this._resolution = t, this._tintFilter && (this._tintFilter.resolution = t), this._blurFilter && (this._blurFilter.resolution = t);
  }
  get distance() {
    return this._distance;
  }
  set distance(t) {
    lib_exports.deprecation("5.3.0", "DropShadowFilter distance is deprecated, use offset"), this._distance = t, this._updatePadding(), this._updateShift();
  }
  get rotation() {
    return this.angle / DEG_TO_RAD;
  }
  set rotation(t) {
    lib_exports.deprecation("5.3.0", "DropShadowFilter rotation is deprecated, use offset"), this.angle = t * DEG_TO_RAD, this._updateShift();
  }
  get alpha() {
    return this._tintFilter.uniforms.alpha;
  }
  set alpha(t) {
    this._tintFilter.uniforms.alpha = t;
  }
  get color() {
    return lib_exports.rgb2hex(this._tintFilter.uniforms.color);
  }
  set color(t) {
    lib_exports.hex2rgb(t, this._tintFilter.uniforms.color);
  }
  get kernels() {
    return this._blurFilter.kernels;
  }
  set kernels(t) {
    this._blurFilter.kernels = t;
  }
  get blur() {
    return this._blurFilter.blur;
  }
  set blur(t) {
    this._blurFilter.blur = t, this._updatePadding();
  }
  get quality() {
    return this._blurFilter.quality;
  }
  set quality(t) {
    this._blurFilter.quality = t;
  }
  get pixelSize() {
    return this._blurFilter.pixelSize;
  }
  set pixelSize(t) {
    this._blurFilter.pixelSize = t;
  }
};
var F = o;
F.defaults = { offset: { x: 4, y: 4 }, color: 0, alpha: 0.5, shadowOnly: false, kernels: null, blur: 2, quality: 3, pixelSize: 1, resolution: settings.FILTER_RESOLUTION };
export {
  F as DropShadowFilter
};
/*! Bundled license information:

@pixi/filter-kawase-blur/dist/filter-kawase-blur.mjs:
  (*!
   * @pixi/filter-kawase-blur - v5.1.1
   * Compiled Wed, 11 Jan 2023 23:10:33 UTC
   *
   * @pixi/filter-kawase-blur is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)

@pixi/filter-drop-shadow/dist/filter-drop-shadow.mjs:
  (*!
   * @pixi/filter-drop-shadow - v5.2.0
   * Compiled Tue, 28 Feb 2023 14:24:35 UTC
   *
   * @pixi/filter-drop-shadow is licensed under the MIT License.
   * http://www.opensource.org/licenses/mit-license
   *)
*/
//# sourceMappingURL=@pixi_filter-drop-shadow.js.map
